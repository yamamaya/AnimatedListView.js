<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated List View</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 800px;
            height: 100%;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 15px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 50px;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
            font-family: monospace;
        }

        /* List view styles */
        .list-container {
            box-sizing: border-box;
            border: 1px solid dimgray;
            background-color: darkgrey;
            overflow-y: auto;
            overflow-x: hidden;
            flex-grow: 1;
            position: relative;
        }

        /* Styles for elements under the list view */
        .list-container * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Basic style for items */
        .list-container .list-item {
            height: 60px;
            width: 100%;
            background-image: linear-gradient(0deg, #cccccc, #eeeeee);
            display: flex;
            align-items: center;
            padding: 0;
            position: relative;
            overflow: hidden;
        }

        /* Style when an item is selected */
        .list-container .list-item.selected {
            background-color: #eeeeff;
            background-image: linear-gradient(0deg, #ccccdd , #eeeeff);
        }

        /* Style when an item is being added */
        .list-container .list-item.appearing {
            animation-name: appear;
            animation-duration: 0.5s;
            animation-timing-function: ease;
            animation-fill-mode: forwards;
        }

        /* Style when an item is being removed */
        .list-container .list-item.disappearing {
            animation-name: disappear;
            animation-duration: 0.5s;
            animation-timing-function: ease;
            animation-fill-mode: forwards;
        }

        /* Style when an item is being moved (extracted) */
        .list-container .list-item.extracted {
            animation-name: extract;
            animation-duration: 0.5s;
            animation-timing-function: ease;
            animation-fill-mode: forwards;
        }

        /* Style when an item is being moved (inserted) */
        .list-container .list-item.inserting {
            animation-name: insert;
            animation-duration: 0.5s;
            animation-timing-function: ease;
            animation-fill-mode: forwards;
        }

        /* Style for empty rows when an item is being added */
        .list-container .row-expanding {
            overflow: hidden;
            transition-property: height;
            transition-duration: 0.5s;
            /* Transition duration (same as .row-collapsing) */
            transition-timing-function: ease;
            background-color: transparent;
            background-image: none;
        }

        /* Style for empty rows when an item is being removed */
        .list-container .row-collapsing {
            overflow: hidden;
            transition-property: height;
            transition-duration: 0.5s;
            /* Transition duration (same as .row-expanding) */
            transition-timing-function: ease;
            background-color: transparent;
            background-image: none;
        }

        /* Temporary container style for moving items */
        .list-container .fixed-container {
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        /* Style for empty items */
        .list-container .empty-row {
            background-color: transparent;
            background-image: none;
        }

        /* Animation when an item is being added */
        @keyframes appear {
            from {
                opacity: 0;
                transform: translateX(0);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Animation when an item is being removed */
        @keyframes disappear {
            from {
                opacity: 1;
                transform: translateX(0);
            }

            to {
                opacity: 0;
                transform: translateX(0);
            }
        }

        /* Animation when an item is being moved (extracted) */
        @keyframes extract {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Animation when an item is being moved (inserted) */
        @keyframes insert {
            0% {
                opacity: 0;
                transform: translateX(100%);
            }

            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Animated List View</h1>

        <div class="controls">
            <button id="addBtn">Add</button>
            <button id="insertBtn">Insert</button>
            <input type="number" id="insertPos" min="0" value="0" placeholder="Position">
            <button id="removeBtn">Remove</button>
            <input type="number" id="removePos" min="0" value="0" placeholder="Position">
            <button id="moveBtn">Move</button>
            <input type="number" id="moveFrom" min="0" value="0" placeholder="From Position">
            <input type="number" id="moveTo" min="0" value="1" placeholder="To Position">
        </div>

        <div id="listView">
            <!-- The content of the list view will be displayed here -->
        </div>

        <div class="status" id="status">Status: Ready</div>
    </div>

    <script>
        /**
         * AnimatedListView class
         * A class that provides an animated list view
         */
        class AnimatedListView {
            // Private fields
            #container;             // Container to display the list view
            #items = [];            // Array to store list items
            #itemHeight;            // Height of an item
            #animationQueue;        // Animation queue
            #isSelectable = false;  // Flag to indicate if items are selectable
            #selectionChangedCallback; // Callback when selection state changes

            /**
             * Constructor
             * @param {string} containerId ID of the container to display the list view
             */
            constructor(containerId, isSelectable = false, selectionChangedCallback = null) {
                // Get the container element
                this.#container = document.getElementById(containerId);
                if (!this.#container) {
                    throw new Error(`Container with ID '${containerId}' not found.`);
                }

                // Set the flag for whether items are selectable
                this.#isSelectable = isSelectable;

                // Set the callback for when the selection state changes
                this.#selectionChangedCallback = selectionChangedCallback;

                // Set the style of the container
                this.#container.classList.add('list-container');

                // Measure the height of an item
                // Create and insert an empty row
                let item = AnimatedListView.#createEmptyRow();
                this.#container.appendChild(item);
                // Get the height
                this.#itemHeight = item.offsetHeight;
                // Remove the empty row
                this.#container.removeChild(item);

                // Initialize the animation queue
                this.#animationQueue = new AnimatedListView.#TicketQueue();
            }

            /**
             * Add the specified element to the end of the list
             * @param {HTMLElement} element The element to add
             * @returns {Promise} A promise that resolves when the animation is complete
             */
            async add(element) {
                // Create an item
                const item = this.#createItem(element);

                // Update the item list
                this.#items.push(item);

                // Join the queue and wait for your turn
                const ticket = this.#animationQueue.join();
                await this.#animationQueue.waitForMyTurn(ticket);

                // Add the new element to the list
                item.node.classList.add('appearing');
                this.#container.appendChild(item.node);

                // Get the animation duration
                var animationDuration = AnimatedListView.#getAnimationDuration(item.node);

                // Wait for the animation to complete
                return new Promise(resolve => {
                    setTimeout(() => {
                        // End the animation
                        item.node.classList.remove('appearing');
                        // Leave the queue
                        this.#animationQueue.leave(ticket);
                        // Resolve
                        resolve();
                    }, animationDuration);
                });
            }

            /**
             * Insert the specified element at the specified position
             * @param {HTMLElement} element The element to insert
             * @param {number} position The position to insert at
             * @returns {Promise} A promise that resolves when the animation is complete
             */
            async insert(element, position) {
                // Restrict the position to the valid range
                position = Math.max(0, Math.min(position, this.#items.length));

                // If the position is at the end, delegate to add
                if (position >= this.#items.length) {
                    return this.add(element);
                }

                // Create an item
                const item = this.#createItem(element);

                // Get the element at the insertion position
                const refElement = this.#items[position].node;

                // Update the item list
                this.#items.splice(position, 0, item);

                // Join the queue and wait for your turn
                const ticket = this.#animationQueue.join();
                await this.#animationQueue.waitForMyTurn(ticket);

                // Create a placeholder element
                const placeholderListItem = AnimatedListView.#createEmptyRow();
                placeholderListItem.classList.add('row-expanding');
                placeholderListItem.style.height = '0px';

                // Add the placeholder element at the insertion position
                this.#container.insertBefore(placeholderListItem, refElement);

                // Wait for the DOM to update
                await new Promise(resolve => {
                    requestAnimationFrame(() => resolve());
                });

                // Get the transition duration
                var durationTransition = AnimatedListView.#getTransitionDuration(placeholderListItem);

                // Set the height of the placeholder element and start the transition
                placeholderListItem.style.height = this.#itemHeight + 'px';

                // Wait for the transition to complete
                await new Promise(resolve => {
                    setTimeout(resolve, durationTransition);
                });

                // Replace the placeholder element with the actual element
                item.node.classList.add('appearing');
                this.#container.replaceChild(item.node, placeholderListItem);

                // Get the animation duration
                var durationAnimation = AnimatedListView.#getAnimationDuration(item.node);

                // Wait for the animation to complete
                return new Promise(resolve => {
                    setTimeout(() => {
                        // End the animation
                        item.node.classList.remove('appearing');
                        // Leave the queue
                        this.#animationQueue.leave(ticket);
                        // Resolve
                        resolve();
                    }, durationAnimation);
                });
            }

            /**
             * Remove the element at the specified position
             * @param {number} position The position of the element to remove
             * @returns {Promise} A promise that resolves when the animation is complete
             */
            async remove(position) {
                // Restrict the position to the valid range
                position = Math.max(0, Math.min(position, this.#items.length - 1));

                // Get the element to remove
                const itemToRemove = this.#items[position].node;
                const itemHeight = itemToRemove.offsetHeight;

                // Update the item list
                this.#items.splice(position, 1);

                // Join the queue and wait for your turn
                const ticket = this.#animationQueue.join();
                await this.#animationQueue.waitForMyTurn(ticket);

                // Fade out the element
                itemToRemove.classList.add('disappearing');

                // Get the animation duration
                var animationDuration = AnimatedListView.#getAnimationDuration(itemToRemove);

                // Wait for the fade-out to complete
                await new Promise(resolve => {
                    setTimeout(resolve, animationDuration);
                });

                // Replace the element to be removed with a placeholder element
                const placeholderListItem = AnimatedListView.#createEmptyRow();
                placeholderListItem.classList.add('row-collapsing');
                placeholderListItem.style.height = itemHeight + 'px';
                this.#container.replaceChild(placeholderListItem, itemToRemove);

                // Wait for the DOM to update
                await new Promise(resolve => {
                    requestAnimationFrame(() => resolve());
                });

                // Get the transition duration
                var durationTransition = AnimatedListView.#getTransitionDuration(placeholderListItem);

                // Set the height of the placeholder element to 0 and start the transition
                placeholderListItem.style.height = '0px';

                // Wait for the transition to complete
                await new Promise(resolve => {
                    setTimeout(resolve, durationTransition);
                });

                // Remove the placeholder element
                this.#container.removeChild(placeholderListItem);

                // Leave the queue
                this.#animationQueue.leave(ticket);

                return Promise.resolve();
            }

            /**
             * Move the element from one position to another
             * @param {number} fromPosition The position to move from
             * @param {number} toPosition The position to move to
             * @returns {Promise} A promise that resolves when the animation is complete
             */
            async move(fromPosition, toPosition) {
                // Restrict the positions to the valid range
                fromPosition = Math.max(0, Math.min(fromPosition, this.#items.length - 1));
                toPosition = Math.max(0, Math.min(toPosition, this.#items.length - 1));

                // If the source and destination positions are the same, do nothing
                if (fromPosition === toPosition) {
                    return Promise.resolve();
                }

                // Backup the item list in the current order
                // This is for performing animations after updating the list
                let itemsBackup = this.#items.slice();

                // Update the item list
                if (fromPosition < toPosition) {
                    // If from < to, remove first and then insert
                    this.#items.splice(toPosition, 0, this.#items.splice(fromPosition, 1)[0]);
                } else {
                    // If to < from, adjust the insertion position and then remove
                    const item = this.#items.splice(fromPosition, 1)[0];
                    this.#items.splice(toPosition, 0, item);
                }

                // Join the queue and wait for your turn
                const ticket = this.#animationQueue.join();
                await this.#animationQueue.waitForMyTurn(ticket);

                // To prevent the list from jittering due to transition discrepancies,
                // move the elements in the target range to a temporary container,
                // perform animations within the container, and then move them back to their original positions.

                // Calculate the range of the target area
                var rangeBegin = Math.min(fromPosition, toPosition);
                var rangeEnd = Math.max(fromPosition, toPosition);

                // Get the element to move
                const itemToMove = itemsBackup[fromPosition].node;
                const itemHeight = itemToMove.offsetHeight;

                // Get the first element in the target range
                const refElement = itemsBackup[rangeBegin].node;

                // Create a temporary container and insert it at the beginning of the target range
                const fixedContainer = document.createElement('div');
                fixedContainer.classList.add('fixed-container');
                this.#container.insertBefore(fixedContainer, refElement);

                // Move elements to the temporary container
                let totalHeight = 0; // Total height
                for (let i = rangeBegin; i <= rangeEnd; i++) {
                    const item = itemsBackup[i].node;
                    // Calculate the height and add it to the total
                    totalHeight += item.offsetHeight;
                    // Move the item to the temporary container
                    this.#container.removeChild(item);
                    fixedContainer.appendChild(item);
                }

                // Set the height of the temporary container
                fixedContainer.style.height = `${totalHeight}px`;

                // Apply the extraction animation to the element to move
                itemToMove.classList.add('extracted');

                // Get the animation duration
                var animationDuration = AnimatedListView.#getAnimationDuration(itemToMove);

                // Wait for the animation to complete
                await new Promise(resolve => {
                    setTimeout(resolve, animationDuration);
                });

                // End the animation
                itemToMove.classList.remove('extracted');

                var placeholderFrom = AnimatedListView.#createEmptyRow();
                placeholderFrom.classList.add('row-collapsing');
                placeholderFrom.style.height = itemHeight + 'px';
                var placeholderTo = AnimatedListView.#createEmptyRow();
                placeholderTo.classList.add('row-expanding');
                placeholderTo.style.height = '0px';

                // Replace the source element with a placeholder element
                fixedContainer.replaceChild(placeholderFrom, itemToMove);

                // Calculate the position within the fixedContainer for the destination
                let insertPosition;
                if (fromPosition < toPosition) {
                    // If from < to, adjust the insertion position by one
                    insertPosition = toPosition - rangeBegin + 1;
                } else {
                    // If to < from, calculate directly
                    insertPosition = toPosition - rangeBegin;
                }

                // Insert the placeholder element at the destination
                fixedContainer.insertBefore(placeholderTo, fixedContainer.children[insertPosition]);

                // Wait for the DOM to update
                await new Promise(resolve => {
                    requestAnimationFrame(() => resolve());
                });

                // Get the transition duration
                var durationTransition = AnimatedListView.#getTransitionDuration(placeholderTo);

                // Set the height of the placeholder elements and start the transition
                placeholderTo.style.height = itemHeight + 'px';
                placeholderFrom.style.height = '0px';

                // Wait for the transition to complete
                await new Promise(resolve => {
                    setTimeout(resolve, durationTransition);
                });

                // Replace the destination placeholder element with the actual element
                fixedContainer.replaceChild(itemToMove, placeholderTo);
                itemToMove.classList.add('inserting');

                // Remove the source placeholder element
                fixedContainer.removeChild(placeholderFrom);

                // Get the animation duration
                var durationAnimation = AnimatedListView.#getAnimationDuration(itemToMove);

                // Wait for the animation to complete
                await new Promise(resolve => {
                    setTimeout(resolve, durationAnimation);
                });

                // End the animation
                itemToMove.classList.remove('inserting');

                // Remove the contents from the temporary container
                while (fixedContainer.firstChild) {
                    // Remove the child element and insert it before the temporary container
                    const item = fixedContainer.firstChild;
                    fixedContainer.removeChild(item);
                    this.#container.insertBefore(item, fixedContainer);
                }

                // Remove the temporary container
                this.#container.removeChild(fixedContainer);

                // Leave the queue
                this.#animationQueue.leave(ticket);

                return Promise.resolve();
            }

            /**
             * Get the element at the specified position
             * @param {number} position The position of the element to get
             * @returns {HTMLElement|null} The element, or null if the position is invalid
             */
            getElement(position) {
                if (position >= 0 && position < this.#items.length) {
                    return this.#items[position].content;
                }
                return null;
            }

            /**
             * Get the number of items in the list
             * @returns {number} The number of items in the list
             */
            getCount() {
                return this.#items.length;
            }

            /**
             * Utility function to get the animation duration
             * @param {HTMLElement} element The element to get the animation duration for
             * @returns {number} The animation duration in milliseconds
             */
            static #getAnimationDuration(element) {
                return parseFloat(getComputedStyle(element).animationDuration) * 1000;
            }

            /**
             * Utility function to get the transition duration
             * @param {HTMLElement} element The element to get the transition duration for
             * @returns {number} The transition duration in milliseconds
             */
            static #getTransitionDuration(element) {
                return parseFloat(getComputedStyle(element).transitionDuration) * 1000;
            }

            /**
             * Utility function to create a placeholder element
             * @param {HTMLElement} node The content of the placeholder element
             * @returns {HTMLElement} The created placeholder element
             */
            #createListItem(node) {
                // Create a div element
                const listItem = document.createElement('div');

                // Add the list item class
                listItem.classList.add('list-item');

                // Add the content of the list item
                listItem.appendChild(node);

                // If selectable, add a click event
                if (this.#isSelectable) {
                    listItem.onclick = () => { // Handle the click event
                        // Add the selected state to itself, remove the selected state from other elements
                        this.#items.forEach(item => {
                            if (item.node === listItem) {
                                item.node.classList.add('selected');
                            } else {
                                item.node.classList.remove('selected');
                            }
                        });

                        // Call the callback when the selection state changes
                        if (this.#selectionChangedCallback) {
                            this.#selectionChangedCallback(listItem);
                        }
                    };
                }

                return listItem;
            }

            /**
             * Utility function to create a list item
             * @param {HTMLElement} node The content of the list item
             * @returns {Object} The created list item object
             */
            #createItem(node){
                return {
                    content: node,
                    node: this.#createListItem(node)
                };
            }

            /**
             * Utility function to create an empty row
             * @returns {HTMLElement} The created empty row element
             */
            static #createEmptyRow() {
                const item = document.createElement('div');
                item.classList.add('list-item');
                item.classList.add('empty-row');
                return item;
            }

            /**
             * Utility function to create a text element with side padding
             * @param {string} text The text content
             * @param {number} padding The size of the side padding
             * @returns {HTMLElement} The created text element
             */
            static createTextItemWithSidePadding(text, padding = 0) {
                const node = document.createElement('div');
                node.textContent = text;
                node.style.padding = `0 ${padding}px`;
                return node;
            }
           
            /**
             * Inner class: TicketQueue
             * A class that implements a ticket-based waiting queue
             * - Join the queue and get a ticket (join)
             * - Check if it's your turn (isMyTurn)
             * - Return the ticket and leave the queue (leave)
             * - Wait asynchronously until it's your turn (waitForMyTurn)
             */
            static #TicketQueue = class {
                #queue;         // Array to store tickets
                #ticketCounter; // Counter to generate ticket numbers
                #waiters;       // Manage waiting promises (ticket -> resolver)

                /**
                 * Constructor
                 */
                constructor() {
                    this.#queue = []; // Array to store tickets
                    this.#ticketCounter = 0; // Counter to generate ticket numbers
                    this.#waiters = new Map(); // Manage waiting promises (ticket -> resolver)
                }

                /**
                 * Join the queue and get a ticket
                 * @returns {number} The ticket number
                 */
                join() {
                    // Generate a ticket number
                    const ticket = this.#ticketCounter++;
                    // Add the ticket to the queue
                    this.#queue.push(ticket);
                    return ticket;
                }

                /**
                 * Check if it's your turn
                 * @param {number} ticket The ticket number
                 * @returns {boolean} Whether it's your turn
                 */
                isMyTurn(ticket) {
                    if (this.#queue.length === 0) {
                        return false;
                    }
                    return this.#queue[0] === ticket;
                }

                /**
                 * Return the ticket and leave the queue
                 * @param {number} ticket The ticket number
                 * @returns {number} The ticket number that left the queue
                 */
                leave(ticket) {
                    if (this.#queue.length === 0) {
                        throw new Error("Queue is empty");
                    }
                    if (this.#queue[0] !== ticket) {
                        throw new Error("Ticket does not match the front of the queue");
                    }
                    // Remove the ticket at the front
                    const removedTicket = this.#queue.shift();

                    // Notify the next waiter
                    if (this.#queue.length > 0) {
                        // Get the next ticket at the front
                        const nextTicket = this.#queue[0];
                        // If the next ticket has a waiting promise, resolve it
                        const resolver = this.#waiters.get(nextTicket);
                        if (resolver) {
                            resolver(nextTicket);
                            this.#waiters.delete(nextTicket);
                        }
                    }
                    return removedTicket;
                }

                /**
                 * Wait asynchronously until it's your turn
                 * @param {number} ticket The ticket number
                 * @returns {Promise<number>} The ticket number when it's your turn
                 */
                async waitForMyTurn(ticket) {
                    if (this.isMyTurn(ticket)) {
                        return ticket; // If already at the front, resolve immediately
                    }

                    // Create a promise and register it in the waiting list
                    return new Promise(resolve => {
                        this.#waiters.set(ticket, resolve);
                    });
                }
            };
        }

        // Demonstration code
        document.addEventListener('DOMContentLoaded', () => {
            const listView = new AnimatedListView(
                containerId = 'listView', 
                isSelectable = true,
                selectionChangedCallback = (selectedItem) => {
                    updateStatus(`Selected item: ${selectedItem.textContent}`);
                }
            );
            const statusElement = document.getElementById('status');
            let itemCounter = 1;

            function updateStatus(message) {
                statusElement.textContent = `Status: ${message}`;
            }

            // Add button
            document.getElementById('addBtn').addEventListener('click', async () => {
                updateStatus('Adding...');
                const node = AnimatedListView.createTextItemWithSidePadding(`Item ${itemCounter++}`, 15);
                await listView.add(node);
                updateStatus(`Add complete. Item count: ${listView.getCount()}`);
                dumpList();
            });

            // Insert button
            document.getElementById('insertBtn').addEventListener('click', async () => {
                const position = parseInt(document.getElementById('insertPos').value);
                updateStatus(`Inserting at position ${position}...`);
                const node = AnimatedListView.createTextItemWithSidePadding(`Inserted Item ${itemCounter++}`, 15);
                await listView.insert(node, position);
                updateStatus(`Insert complete. Item count: ${listView.getCount()}`);
                dumpList();
            });

            // Remove button
            document.getElementById('removeBtn').addEventListener('click', async () => {
                const position = parseInt(document.getElementById('removePos').value);
                if (listView.getCount() === 0) {
                    updateStatus('No items to remove.');
                    return;
                }
                updateStatus(`Removing item at position ${position}...`);
                await listView.remove(position);
                updateStatus(`Remove complete. Item count: ${listView.getCount()}`);
                dumpList();
            });

            // Move button
            document.getElementById('moveBtn').addEventListener('click', async () => {
                const fromPosition = parseInt(document.getElementById('moveFrom').value);
                const toPosition = parseInt(document.getElementById('moveTo').value);
                if (listView.getCount() <= 1) {
                    updateStatus('Not enough items to move.');
                    return;
                }
                updateStatus(`Moving from position ${fromPosition} to ${toPosition}...`);
                await listView.move(fromPosition, toPosition);
                updateStatus(`Move complete. Item count: ${listView.getCount()}`);
                dumpList();
            });

            function dumpList() {
                console.log('----- dumpList -----');
                for (let i = 0; i < listView.getCount(); i++) {
                    console.log(`[${i}]: ${listView.getElement(i).textContent}`);
                }
            }

            // Add initial items
            (async () => {
                for (let i = 0; i < 5; i++) {
                    await listView.add(AnimatedListView.createTextItemWithSidePadding(`Initial Item ${itemCounter++}`, 15));
                }
                updateStatus(`Ready. Item count: ${listView.getCount()}`);
            })();
        });
    </script>
</body>

</html>